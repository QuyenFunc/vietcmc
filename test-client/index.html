<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VietCMS Moderation Test Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
        }

        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            min-height: 100px;
            resize: vertical;
            font-family: inherit;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            margin-top: 10px;
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            margin-top: 10px;
        }

        .results {
            grid-column: 1 / -1;
        }

        .result-item {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
        }

        .result-item.approved {
            border-left-color: #28a745;
        }

        .result-item.rejected {
            border-left-color: #dc3545;
        }

        .result-item.pending {
            border-left-color: #ffc107;
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .status-badge {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-badge.approved {
            background: #d4edda;
            color: #155724;
        }

        .status-badge.rejected {
            background: #f8d7da;
            color: #721c24;
        }

        .status-badge.pending {
            background: #fff3cd;
            color: #856404;
        }

        .status-badge.processing {
            background: #cce5ff;
            color: #004085;
        }

        .result-content {
            color: #555;
            margin-bottom: 8px;
        }

        .result-meta {
            font-size: 12px;
            color: #888;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .loading {
            display: none;
            text-align: center;
            color: #667eea;
            font-weight: 600;
            margin: 10px 0;
        }

        .loading.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #f5c6cb;
        }

        .success {
            background: #d4edda;
            color: #155724;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #c3e6cb;
        }

        .config-section {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            margin-left: 10px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üõ°Ô∏è VietCMS Moderation Test Client</h1>
            <p>Test v√† ki·ªÉm tra API moderation b√¨nh lu·∫≠n ti·∫øng Vi·ªát</p>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-number" id="totalCount">0</div>
                <div class="stat-label">T·ªïng s·ªë</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="approvedCount">0</div>
                <div class="stat-label">ƒê∆∞·ª£c duy·ªát</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="rejectedCount">0</div>
                <div class="stat-label">B·ªã t·ª´ ch·ªëi</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="pendingCount">0</div>
                <div class="stat-label">ƒêang x·ª≠ l√Ω</div>
            </div>
        </div>

        <div class="main-content">
            <!-- Configuration -->
            <div class="card">
                <h2>‚öôÔ∏è C·∫•u h√¨nh</h2>
                <div class="form-group">
                    <label for="apiUrl">API URL</label>
                    <input type="text" id="apiUrl" value="http://localhost" placeholder="http://localhost">
                </div>
                <div class="form-group">
                    <label for="apiKey">API Key</label>
                    <input type="text" id="apiKey" value="test_api_key_vietcms_2024_abcdef123456" placeholder="your-api-key">
                </div>
                <div class="form-group">
                    <label for="hmacSecret">HMAC Secret</label>
                    <input type="text" id="hmacSecret" value="test_hmac_secret_vietcms_2024_xyz789" placeholder="your-hmac-secret">
                </div>
                <div class="form-group">
                    <label for="webhookUrl">Webhook URL (t√πy ch·ªçn)</label>
                    <input type="text" id="webhookUrl" placeholder="https://your-webhook.com/callback">
                </div>
            </div>

            <!-- Single Comment -->
            <div class="card">
                <h2>üí¨ G·ª≠i b√¨nh lu·∫≠n ƒë∆°n</h2>
                <div class="form-group">
                    <label for="singleComment">N·ªôi dung b√¨nh lu·∫≠n</label>
                    <textarea id="singleComment" placeholder="Nh·∫≠p n·ªôi dung b√¨nh lu·∫≠n c·∫ßn ki·ªÉm tra...">ƒê√¢y l√† m·ªôt b√¨nh lu·∫≠n test</textarea>
                </div>
                <div class="form-group">
                    <label for="contentType">Lo·∫°i n·ªôi dung</label>
                    <select id="contentType">
                        <option value="comment">B√¨nh lu·∫≠n</option>
                        <option value="post">B√†i vi·∫øt</option>
                        <option value="review">ƒê√°nh gi√°</option>
                    </select>
                </div>
                <button onclick="submitSingleComment()">G·ª≠i ki·ªÉm tra</button>
                <div class="loading" id="singleLoading">‚è≥ ƒêang x·ª≠ l√Ω...</div>
            </div>

            <!-- Bulk Testing -->
            <div class="card">
                <h2>üöÄ Test h√†ng lo·∫°t</h2>
                <div class="form-group">
                    <label for="bulkCount">S·ªë l∆∞·ª£ng b√¨nh lu·∫≠n</label>
                    <input type="number" id="bulkCount" value="10" min="1" max="10000">
                </div>
                <div class="form-group">
                    <label for="bulkDelay">ƒê·ªô tr·ªÖ gi·ªØa c√°c request (ms)</label>
                    <input type="number" id="bulkDelay" value="100" min="0" max="5000">
                </div>
                <div class="form-group">
                    <label for="testMode">Ch·∫ø ƒë·ªô test</label>
                    <select id="testMode">
                        <option value="random">Ng·∫´u nhi√™n</option>
                        <option value="safe">Ch·ªâ b√¨nh lu·∫≠n an to√†n</option>
                        <option value="toxic">Ch·ªâ b√¨nh lu·∫≠n ƒë·ªôc h·∫°i</option>
                        <option value="mixed">H·ªón h·ª£p (50/50)</option>
                    </select>
                </div>
                <button onclick="startBulkTest()" id="bulkBtn">B·∫Øt ƒë·∫ßu test</button>
                <button onclick="stopBulkTest()" class="btn-secondary" id="stopBtn" disabled>D·ª´ng l·∫°i</button>
                <div class="progress-bar" style="margin-top: 15px;">
                    <div class="progress-fill" id="bulkProgress" style="width: 0%"></div>
                </div>
                <div class="loading" id="bulkLoading"></div>
            </div>

            <!-- Status Checker -->
            <div class="card">
                <h2>üìä Ki·ªÉm tra tr·∫°ng th√°i</h2>
                <div class="form-group">
                    <label for="jobId">Job ID</label>
                    <input type="text" id="jobId" placeholder="Nh·∫≠p job_id ƒë·ªÉ ki·ªÉm tra">
                </div>
                <button onclick="checkStatus()">Ki·ªÉm tra</button>
                <button onclick="checkAllPending()" class="btn-success">Ki·ªÉm tra t·∫•t c·∫£ ƒëang x·ª≠ l√Ω</button>
                <div class="loading" id="statusLoading">‚è≥ ƒêang ki·ªÉm tra...</div>
            </div>

            <!-- Results -->
            <div class="card results">
                <h2>üìù K·∫øt qu·∫£</h2>
                <div style="margin-bottom: 15px;">
                    <button onclick="clearResults()" class="btn-secondary">X√≥a k·∫øt qu·∫£</button>
                    <button onclick="exportResults()" class="btn-success">Xu·∫•t JSON</button>
                </div>
                <div id="resultsList"></div>
            </div>
        </div>
    </div>

    <script>
        let results = [];
        let bulkTestRunning = false;
        let pendingJobs = new Set();

        // HMAC-SHA256 signing function
        async function signPayload(secret, payload) {
            const encoder = new TextEncoder();
            const keyData = encoder.encode(secret);
            const messageData = encoder.encode(payload);
            
            const cryptoKey = await crypto.subtle.importKey(
                'raw',
                keyData,
                { name: 'HMAC', hash: 'SHA-256' },
                false,
                ['sign']
            );
            
            const signature = await crypto.subtle.sign('HMAC', cryptoKey, messageData);
            const hashArray = Array.from(new Uint8Array(signature));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            
            return 'sha256=' + hashHex;
        }

        const safeComments = [
            'S·∫£n ph·∫©m r·∫•t t·ªët, t√¥i r·∫•t h√†i l√≤ng',
            'Ch·∫•t l∆∞·ª£ng d·ªãch v·ª• xu·∫•t s·∫Øc',
            'Giao h√†ng nhanh, ƒë√≥ng g√≥i c·∫©n th·∫≠n',
            'Nh√¢n vi√™n t∆∞ v·∫•n nhi·ªát t√¨nh',
            'Gi√° c·∫£ h·ª£p l√Ω, ƒë√°ng ti·ªÅn',
            'S·∫Ω ti·∫øp t·ª•c ·ªßng h·ªô shop',
            'ƒê√∫ng nh∆∞ m√¥ t·∫£, r·∫•t ∆∞ng √Ω',
            'C·∫£m ∆°n shop nhi·ªÅu',
            'S·∫£n ph·∫©m ch·∫•t l∆∞·ª£ng cao',
            'ƒê√≥ng g√≥i ƒë·∫πp, giao h√†ng ƒë√∫ng h·∫πn'
        ];

        const toxicComments = [
            'ƒê·ªì l·ª´a ƒë·∫£o, b√°n h√†ng d·ªèm',
            'M·∫π ki·∫øp, giao h√†ng ch·∫≠m nh∆∞ r√πa',
            'Ch·∫•t l∆∞·ª£ng nh∆∞ c·ª©t, kh√¥ng n√™n mua',
            'Shop l·ª´a ƒë·∫£o, ƒë·ªì ƒÉn c·∫Øp',
            'ƒê·ªì ngu ng·ªëc, ph√≠ ti·ªÅn',
            'ƒêm, ship l√¢u v√£i c·∫£ l·ªìn',
            'C√∫t ƒëi, shop ƒë·ªì r√°c',
            'ƒê·ªì ch√≥ m√°, kh√¥ng bao gi·ªù mua n·ªØa',
            'L·ª´a ƒë·∫£o kh√°ch h√†ng vl',
            'H√†ng gi·∫£, h√†ng nh√°i, ƒë·ªì d·ªèm'
        ];

        function getRandomComment(mode) {
            if (mode === 'safe') {
                return safeComments[Math.floor(Math.random() * safeComments.length)];
            } else if (mode === 'toxic') {
                return toxicComments[Math.floor(Math.random() * toxicComments.length)];
            } else if (mode === 'mixed') {
                const all = [...safeComments, ...toxicComments];
                return all[Math.floor(Math.random() * all.length)];
            } else {
                // random - mix all
                const all = [...safeComments, ...toxicComments];
                return all[Math.floor(Math.random() * all.length)];
            }
        }

        async function submitSingleComment() {
            const apiUrl = document.getElementById('apiUrl').value;
            const apiKey = document.getElementById('apiKey').value;
            const hmacSecret = document.getElementById('hmacSecret').value;
            const content = document.getElementById('singleComment').value;
            const contentType = document.getElementById('contentType').value;
            const webhookUrl = document.getElementById('webhookUrl').value;

            if (!apiKey) {
                showError('Vui l√≤ng nh·∫≠p API Key');
                return;
            }

            if (!hmacSecret) {
                showError('Vui l√≤ng nh·∫≠p HMAC Secret');
                return;
            }

            const loading = document.getElementById('singleLoading');
            loading.classList.add('active');

            try {
                const payload = {
                    text: content,
                    comment_id: 'comment-' + Date.now(),
                    metadata: {
                        content_type: contentType,
                        user_id: 'test-user-' + Date.now(),
                        timestamp: new Date().toISOString()
                    }
                };

                if (webhookUrl) {
                    payload.metadata.webhook_url = webhookUrl;
                }

                const bodyString = JSON.stringify(payload);
                const signature = await signPayload(hmacSecret, bodyString);

                const response = await fetch(`${apiUrl}/api/v1/submit`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': apiKey,
                        'X-Hub-Signature-256': signature
                    },
                    body: bodyString
                });

                const data = await response.json();

                if (response.ok) {
                    addResult({
                        job_id: data.job_id,
                        content: content,
                        status: 'pending',
                        timestamp: new Date().toISOString()
                    });
                    pendingJobs.add(data.job_id);
                    showSuccess('ƒê√£ g·ª≠i th√†nh c√¥ng! Job ID: ' + data.job_id);
                    
                    // Auto check status after 2 seconds
                    setTimeout(() => checkSpecificStatus(data.job_id), 2000);
                } else {
                    showError('L·ªói: ' + (data.detail || 'Kh√¥ng th·ªÉ g·ª≠i b√¨nh lu·∫≠n'));
                }
            } catch (error) {
                showError('L·ªói k·∫øt n·ªëi: ' + error.message);
            } finally {
                loading.classList.remove('active');
            }
        }

        let bulkAbortController = null;

        async function startBulkTest() {
            const count = parseInt(document.getElementById('bulkCount').value);
            const delay = parseInt(document.getElementById('bulkDelay').value);
            const mode = document.getElementById('testMode').value;
            const apiUrl = document.getElementById('apiUrl').value;
            const apiKey = document.getElementById('apiKey').value;
            const hmacSecret = document.getElementById('hmacSecret').value;

            if (!apiKey || !hmacSecret) {
                showError('Vui l√≤ng nh·∫≠p API Key v√† HMAC Secret');
                return;
            }

            bulkTestRunning = true;
            bulkAbortController = new AbortController();
            document.getElementById('bulkBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;

            const loading = document.getElementById('bulkLoading');
            const progress = document.getElementById('bulkProgress');

            let successCount = 0;
            let errorCount = 0;

            for (let i = 0; i < count && bulkTestRunning; i++) {
                try {
                    const content = getRandomComment(mode);
                    const payload = {
                        text: content,
                        comment_id: 'bulk-' + Date.now() + '-' + i,
                        metadata: {
                            content_type: 'comment',
                            user_id: 'bulk-test-' + i,
                            batch: Date.now()
                        }
                    };

                    const bodyString = JSON.stringify(payload);
                    const signature = await signPayload(hmacSecret, bodyString);

                    const response = await fetch(`${apiUrl}/api/v1/submit`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-API-Key': apiKey,
                            'X-Hub-Signature-256': signature
                        },
                        body: bodyString,
                        signal: bulkAbortController.signal
                    });

                    const data = await response.json();

                    if (response.ok) {
                        successCount++;
                        pendingJobs.add(data.job_id);
                        addResult({
                            job_id: data.job_id,
                            content: content,
                            status: 'pending',
                            timestamp: new Date().toISOString()
                        });
                    } else {
                        errorCount++;
                    }
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        errorCount++;
                    }
                }

                const percentage = ((i + 1) / count * 100).toFixed(1);
                progress.style.width = percentage + '%';
                loading.textContent = `ƒê√£ g·ª≠i: ${i + 1}/${count} | Th√†nh c√¥ng: ${successCount} | L·ªói: ${errorCount}`;
                loading.classList.add('active');

                if (delay > 0 && i < count - 1) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }

            loading.textContent = `‚úÖ Ho√†n th√†nh! Th√†nh c√¥ng: ${successCount} | L·ªói: ${errorCount}`;
            document.getElementById('bulkBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            bulkTestRunning = false;

            // Auto check all after completion
            if (successCount > 0) {
                setTimeout(checkAllPending, 3000);
            }
        }

        function stopBulkTest() {
            bulkTestRunning = false;
            if (bulkAbortController) {
                bulkAbortController.abort();
            }
            document.getElementById('bulkBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('bulkLoading').textContent += ' - ƒê√£ d·ª´ng!';
        }

        async function checkStatus() {
            const jobId = document.getElementById('jobId').value.trim();
            if (!jobId) {
                showError('Vui l√≤ng nh·∫≠p Job ID');
                return;
            }
            await checkSpecificStatus(jobId);
        }

        async function checkSpecificStatus(jobId) {
            const apiUrl = document.getElementById('apiUrl').value;
            const apiKey = document.getElementById('apiKey').value;
            const loading = document.getElementById('statusLoading');

            if (!apiKey) {
                showError('Vui l√≤ng nh·∫≠p API Key');
                return;
            }

            loading.classList.add('active');

            try {
                const response = await fetch(`${apiUrl}/api/v1/status/${jobId}`, {
                    headers: {
                        'X-API-Key': apiKey
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    updateResult(data);
                    if (data.status !== 'pending' && data.status !== 'processing') {
                        pendingJobs.delete(jobId);
                    }
                } else {
                    showError('Kh√¥ng t√¨m th·∫•y job: ' + jobId);
                }
            } catch (error) {
                showError('L·ªói k·∫øt n·ªëi: ' + error.message);
            } finally {
                loading.classList.remove('active');
            }
        }

        async function checkAllPending() {
            if (pendingJobs.size === 0) {
                showError('Kh√¥ng c√≥ job n√†o ƒëang x·ª≠ l√Ω');
                return;
            }

            const loading = document.getElementById('statusLoading');
            loading.textContent = `‚è≥ ƒêang ki·ªÉm tra ${pendingJobs.size} jobs...`;
            loading.classList.add('active');

            const jobIds = Array.from(pendingJobs);
            let completed = 0;

            for (const jobId of jobIds) {
                await checkSpecificStatus(jobId);
                completed++;
                loading.textContent = `‚è≥ ƒê√£ ki·ªÉm tra ${completed}/${jobIds.length} jobs...`;
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            loading.classList.remove('active');
            showSuccess(`ƒê√£ ki·ªÉm tra xong ${completed} jobs!`);
        }

        function addResult(result) {
            results.unshift(result);
            renderResults();
            updateStats();
        }

        function updateResult(result) {
            const index = results.findIndex(r => r.job_id === result.job_id);
            if (index !== -1) {
                results[index] = { ...results[index], ...result };
            } else {
                results.unshift(result);
            }
            renderResults();
            updateStats();
        }

        function renderResults() {
            const container = document.getElementById('resultsList');
            if (results.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #888;">Ch∆∞a c√≥ k·∫øt qu·∫£ n√†o</p>';
                return;
            }

            container.innerHTML = results.map(result => {
                const statusClass = result.status || 'pending';
                const statusText = {
                    'approved': 'ƒê∆∞·ª£c duy·ªát',
                    'rejected': 'B·ªã t·ª´ ch·ªëi',
                    'pending': 'ƒêang ch·ªù',
                    'processing': 'ƒêang x·ª≠ l√Ω'
                }[statusClass] || statusClass;

                let detailsHtml = '';
                if (result.moderation_result) {
                    detailsHtml = `
                        <div style="margin-top: 10px; padding: 10px; background: white; border-radius: 5px;">
                            <strong>K·∫øt qu·∫£ ph√¢n t√≠ch:</strong><br>
                            Quy·∫øt ƒë·ªãnh: ${result.moderation_result.decision}<br>
                            ƒê·ªô tin c·∫≠y: ${(result.moderation_result.confidence * 100).toFixed(1)}%<br>
                            ${result.moderation_result.reason ? 'L√Ω do: ' + result.moderation_result.reason + '<br>' : ''}
                            ${result.moderation_result.flagged_words?.length ? 'T·ª´ ng·ªØ vi ph·∫°m: ' + result.moderation_result.flagged_words.join(', ') : ''}
                        </div>
                    `;
                }

                return `
                    <div class="result-item ${statusClass}">
                        <div class="result-header">
                            <strong>Job ID: ${result.job_id}</strong>
                            <span class="status-badge ${statusClass}">${statusText}</span>
                        </div>
                        <div class="result-content">
                            <strong>N·ªôi dung:</strong> ${result.content || 'N/A'}
                        </div>
                        ${detailsHtml}
                        <div class="result-meta">
                            ${result.timestamp ? new Date(result.timestamp).toLocaleString('vi-VN') : ''}
                            ${result.processed_at ? ' | X·ª≠ l√Ω l√∫c: ' + new Date(result.processed_at).toLocaleString('vi-VN') : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateStats() {
            const total = results.length;
            const approved = results.filter(r => r.status === 'approved').length;
            const rejected = results.filter(r => r.status === 'rejected').length;
            const pending = results.filter(r => r.status === 'pending' || r.status === 'processing').length;

            document.getElementById('totalCount').textContent = total;
            document.getElementById('approvedCount').textContent = approved;
            document.getElementById('rejectedCount').textContent = rejected;
            document.getElementById('pendingCount').textContent = pending;
        }

        function clearResults() {
            if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a t·∫•t c·∫£ k·∫øt qu·∫£?')) {
                results = [];
                pendingJobs.clear();
                renderResults();
                updateStats();
            }
        }

        function exportResults() {
            const dataStr = JSON.stringify(results, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `moderation-results-${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function showError(message) {
            const container = document.getElementById('resultsList');
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            container.insertBefore(errorDiv, container.firstChild);
            setTimeout(() => errorDiv.remove(), 5000);
        }

        function showSuccess(message) {
            const container = document.getElementById('resultsList');
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            container.insertBefore(successDiv, container.firstChild);
            setTimeout(() => successDiv.remove(), 5000);
        }

        // Load saved config from localStorage
        window.addEventListener('load', () => {
            const saved = localStorage.getItem('vietcms-config');
            if (saved) {
                try {
                    const config = JSON.parse(saved);
                    document.getElementById('apiUrl').value = config.apiUrl || 'http://localhost';
                    document.getElementById('apiKey').value = config.apiKey || '';
                    document.getElementById('hmacSecret').value = config.hmacSecret || '';
                } catch (e) {}
            }
        });

        // Save config to localStorage on change
        ['apiUrl', 'apiKey', 'hmacSecret'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                const config = {
                    apiUrl: document.getElementById('apiUrl').value,
                    apiKey: document.getElementById('apiKey').value,
                    hmacSecret: document.getElementById('hmacSecret').value
                };
                localStorage.setItem('vietcms-config', JSON.stringify(config));
            });
        });
    </script>
</body>
</html>

